" THIS FILE IS AUTOGENERATED.

" vim:set fileencoding=utf-8 sw=3 ts=3 et:vim
"
" Author: Marko Mahnič
" Created: February 2010
" License: GPL (http://www.gnu.org/copyleft/gpl.html)
" This program comes with ABSOLUTELY NO WARRANTY.

" [script]: http://www.vim.org/scripts/script.php?script_id=%p
" This script: iw://script/2997
" utl.vim:     iw://script/293
if ! exists('g:loaded_au_utlx_interwiki') || ! g:loaded_au_utlx_interwiki
   let g:loaded_au_utlx_interwiki = 1
else
   finish
endif

" =========================================================================== 
" Local Initialization - on autoload
" =========================================================================== 
if ! exists('g:utlextra_interwikis')
   let g:utlextra_interwikis =  {}
endif
if ! exists('g:utlextra_import_viki')
   let g:utlextra_import_viki =  1
endif
if ! exists('g:utlextra_interwiki_match_case')
   let g:utlextra_interwiki_match_case =  0
endif
" =========================================================================== 

function! s:ParseViki_InterVikis()
   if ! exists('g:vikiInterVikiNames')
      return
   endif
   for iviki in g:vikiInterVikiNames
      let iviki = matchstr(iviki, '^.*\ze::')
      if has_key(g:utlextra_interwikis, iviki)
         continue
      endif
      if ! exists('g:vikiInter' . iviki)
         continue
      endif
      let ivaddr = g:vikiInter{iviki}
      let ivsfx = ''
      if exists('g:vikiInter' . iviki . '_suffix')
         let ivsfx = g:vikiInter{iviki}_suffix
      endif
      let wikidef = [ivaddr, ivsfx]
      let g:utlextra_interwikis[iviki] = wikidef
   endfor
endfunc

" WARNING: wikiName must exist in knownWikis dictionary
function s:GetWikiEntryAsList(wikiName, knownWikis)
   let wikidef = a:knownWikis[a:wikiName]
   if type(wikidef) == 1
      " string --> convert to list [url, default_extension]
      let w = [wikidef, '']
      unlet wikidef
      let wikidef = w
      let a:knownWikis[a:wikiName] = wikidef
   endif
   return wikidef
endfunc

function s:GetWikiDef(wikiName, knownWikis, matchcase)
   if a:matchcase
      let name = a:wikiName
      if ! has_key(a:knownWikis, name)
         return []
      endif
   else
      let name = ''
      let srch = tolower(a:wikiName)
      for wname in keys(a:knownWikis)
         if srch == tolower(wname)
            let name = wname
            break
         endif
      endfor
      if name == ''
         return []
      endif
   endif

   return s:GetWikiEntryAsList(name, a:knownWikis)
endfunc

" Extract interwiki definitions from current buffer.
" Format: ^  [WORD]: URL | default_extension
"  TODO: (maybe) a tag like '[w=WORD]:' instead of '[WORD]:' is probably safer to use
" URL can have a placeholder %% which is replaced with UtlUri_path+fragment.
" Result: list of lists: [ [WORD, URL_ext], [WORD, URL_ext], ... ]
function s:ExtraclLocalWikiDefs()
   let savepos = getpos('.')
   let matches = []
   " TODO: comment-skip is buffer-local; it must not have numbered subexpressions
   let commentskip = '[*"#]\s*\|\/\/\s*\|\/\*\s*|\s*'
   " subexpressions: \1=interwiki_word, \2=URL_ext
   let patt = '\m^\s*\%(' . commentskip . '\)\?\zs\[\(\w\+\)\]:\s*\(\S.*\)$'
   silent norm gg
   silent exec 'g/' . patt . '/call add(matches, getline("."))'
   call setpos('.', savepos)
   call map(matches, 'matchlist(v:val, patt)[1:2]')
   let iwdef = {}
   for [iwk, val] in matches
      let defparts = split(val, '\s*|\s*')[:2]
      if len(defparts) < 2
         call add(defparts, '')
      end
      let iwdef[iwk] = defparts
   endfor
   "echo matches
   "echo iwdef
   "echom "Wait"
   return iwdef
endfunc

function! s:FindCurrentWiki(path)
   for iwdef in [b:utlextra_interwikis, g:utlextra_interwikis]
      for wiki in keys(iwdef)
         let wikidef = s:GetWikiEntryAsList(wiki, iwdef)
         if len(wikidef) < 1
            continue
         endif
         if wikidef[0] == a:path
            return wiki
         endif
      endfor
   endfor
   return ''
endfunc


" Support for InterWiki linking.
" Formats:
"    iw://log/200902#tn=2009-02-17
"    iw://log/subdir/in/log/200902#tn=2009-02-17
"    iw://page_in_current_wiki    (only for pages in top directory of a wiki)
" Example:
"    iw://log/200902#tn=2009-02-17
" Convert 'log' to 'file://path/to/wiki/LOG' and '200902' to '200902.viki'
"    1) find entry for 'log' (scheme, url, ext) or url
"    2) build the new uri (add basepath, add extension if defined)
"    3) return Utl_AddressScheme_{scheme}(new_uri)
"  Doc: <../plugin/utl_scm.vim#r=implscmfunc>
function! utlx_interwiki#HandleScheme_interwiki(auri, fragment, mode, utl_version)
   if g:utlextra_import_viki > 0
      call s:ParseViki_InterVikis()
      let g:utlextra_import_viki = 0
   endif
   if ! exists('b:utlextra_interwikis') || ! exists('b:utlextra_interwikis_chgtck') 
            \ || b:utlextra_interwikis_chgtck != b:changedtick
      let b:utlextra_interwikis = s:ExtraclLocalWikiDefs()
      let b:utlextra_interwikis_chgtck = b:changedtick
   endif

   let scheme = UtlUri_scheme(a:auri)
   let wiki = UtlUri_authority(a:auri)
   let path = UtlUri_path(a:auri)
   let query = UtlUri_query(a:auri)
   if a:utl_version < 3 | let result = ''
   else | let result = [] | endif
   if path == '' 
      if wiki == ''
         echom 'Utl_InterWiki: Malformed interwiki: "' . a:auri . '"'
         return result
      endif
   endif

   " If wiki is not given, try to find a wiki pointing to the current directory
   if wiki == '' || wiki == '.'
      let b:utlextra_interwikis['!local'] = ['!', ''] " easier than removing
      let bufdir = fnamemodify(expand('%'), ':p:h')
      let wiki = s:FindCurrentWiki(bufdir)
      if wiki == ''
         " Create an entry for the current directory with extension of current buffer
         let wiki = '!local'
         let ext = '.' . fnamemodify(expand('%'), ':e')
         let b:utlextra_interwikis[wiki] = [bufdir, ext]
      endif
   endif
   
   " Find an interwiki definition. Fist try local definitions, then global.
   let wikidef = []
   " Try matching with exact case first
   if len(wikidef) < 1
      let wikidef = s:GetWikiDef(wiki, b:utlextra_interwikis, 1)
   endif
   if len(wikidef) < 1
      let wikidef = s:GetWikiDef(wiki, g:utlextra_interwikis, 1)
   endif

   " Try matching with ignorecase if a match has not been found
   if ! g:utlextra_interwiki_match_case
      if len(wikidef) < 1
         let wikidef = s:GetWikiDef(wiki, b:utlextra_interwikis, 0)
      endif
      if len(wikidef) < 1
         let wikidef = s:GetWikiDef(wiki, g:utlextra_interwikis, 0)
      endif
   endif
   if len(wikidef) < 1
      echom 'Utl_InterWiki: Unknown wiki "' . wiki . '"'
      return result
   endif

   let newscheme = UtlUri_scheme(wikidef[0])
   if newscheme == '<undef>'
      let newscheme = 'file'
   endif

   " If %p is in newauri, it is replaced with path, otherwise path
   " will be appended to basepath
   let newauri = wikidef[0]
   let ppos = match(newauri, '%p')
   if  ppos >= 0
      let qpos = match(newauri, '\m?')
      echom '%' . ppos . ' ?' . qpos
      if qpos < ppos
         let path = substitute(path, '^/*\(.*\)/*$', '\1', '')
      endif
      let newauri = substitute(newauri, '%p', path, '')
      let path = ''
   endif
   let authority = UtlUri_authority(newauri)
   let basepath = UtlUri_path(newauri)
   let basequery = UtlUri_query(newauri)
   if newscheme == 'file' && wikidef[1] != ''
      let ext = fnamemodify(path, ':e')
      if ext == ''
         let path = path . wikidef[1]
      endif
   endif

   if newscheme != scheme && exists('*Utl_AddressScheme_' . newscheme)
      if basequery != '<undef>'
         if query == '<undef>'
            let query = basequery
         else
            let query = basequery . query
         endif
      endif
      let newuri = UtlUri_build(newscheme, authority, basepath . path, query, '<undef>') 
      let frag = a:fragment
      if frag == '<undef>'
         let frag = ''
      endif
      if a:utl_version < 3
         let result = Utl_AddressScheme_{newscheme}(newuri)
      else
         let result = Utl_AddressScheme_{newscheme}(newuri, frag, a:mode)
      endif
      return result
   endif
   return result
endfunc

